# LeetCode
The algorithms form [Leetcode](https://leetcode.cn/).
## 目标
- 能够在**25min**之内完成中等难度的题目
## 方法
循序渐进:
- 1刷主要看代码实现, 熟悉相关编程语言, 对着答案自己实现一遍, 适合几乎没有基础的新手.
- 2刷主要看解题思路, 有了思路之后不看答案自己编程实现一遍.
- 3刷总结主要方法, 对数据结构和方法分门别类, 总结同一类型题目的区别.
- 4刷组合已经学到的方法, 解决更加复杂的问题.
## 原则
- 重点在于理解并记忆现有的解题思路, 而不是自己想.
- 关注算法本身的复杂度, 而不是打败了多少...的数据
- 思路 + 代码细节两条腿走路
- 主要关注最常见的算法, 冷门的解决方式在面试时不会得到认可
- 题目阅读时要明确函数的输入和输出
## 代码编写
- 由于刷题时会看各个不同来源的讲解, 代码风格会很不一样, 所以需要自己做好统一.
- 代码清晰程度 > 代码简洁程度
### 注意事项
- 边界条件要再三确认, >= > == < <= 和 +1 -1等
### 命名
- 返回的结果可以命名为 res(result)或者 ans(answer).
- 左右区间的命名可以从如下中选择
  - left / right
  - begin(start) / end
  - first / last
- 表示已经访问过的地方
  - 当前位置 cur(current)
  - 上一个位置 prev(previous)
  - 下一个位置 next
## 算法
### 二分查找Binary Search
- 需要明确区间的开闭性, 左闭右开(满足C++/Python的语言习惯)或者左闭右闭(便于处理边界条件).
- 直接用(right + left) / 2可能在计算加法时出现溢出, left + (right - left) / 2可以避免这种情况.
### 回溯法Backtracking
- 一种通过探索所有可能的候选解来找出所有的解的算法. 如果候选解被确认不是一个解(或者至少不是最后一个解), 回溯算法会通过在上一步进行一些变化抛弃该解, 即回溯并且再次尝试.
- 回溯算法首先需要画出递归树, 不同的树决定了不同的代码实现.
### 动态规划Dynamic Programming
- 通过`组合子问题`的解来求解原问题, 在这里Programming指的是一种表格法, 并非编写计算机程序
- 解决动态规划问题的关键是找到`状态转移方程`
- 可以对动态规划进行`空间压缩`
- 命名: 数组的命名用dp; 经常会用到当前位置cur, 前面一个位置pre. 如果需要多个前面的位置可以命名为pre1, pre2...
### 广度优先搜索Breadth-First Search
- 命名: 可以预先定义一个数组用来表示查找的方向:
```
const std::vector<std::vector<int>> directions = {
    {1, 0}, {-1, 0}, {0, -1}, {0, 1}};
```
- 命名: 表示已经访问过的地方: `std::vector<std::vector<int>> is_visited;`